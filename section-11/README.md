# 11. 更新模块

随着模块开始使用，可能需要修改该模块。但是，如果已发布的模块发生更改，如果它们有可能导致使用原始规范的客户端与使用更新的规范的服务器之间的互操作性问题，则不允许进行更改。

对于任何已发布的变更，新的“`revision`”声明（[第7.1.9节](../section-7/7.1.md#719-revision声明)）必须包含在现有“`revision`”声明的前面。如果没有现有的“`revision`”语句，则必须添加一个以确定新的修订版本。此外，任何必要的变更必须适用于任何元数据声明，包括“`organization`”和“`contact`”声明（[7.1.7](../section-7/7.1.md#717-organization声明)和[7.1.8](../section-7/7.1.md#718-contact声明)节）。

请注意，模块中包含的定义可供任何其他模块导入，并通过模块名称在“`import`”语句中引用。因此，模块名称不能被改变。而且，“`namespace`”语句不能被改变，因为所有的`XML`元素都被命名空间限定了。

过时的定义不能从发布的模块中移除，因为它们的标识符可能仍然被其他模块引用。

已发布模块中的定义可以通过以下任何方式进行修改：

 - “`enumeration`”类型可能会添加新的枚举，前提是旧枚举的值不会更改。请注意，在现有枚举之前插入一个新枚举或重新排序现有枚举将导致现有枚举的新值，除非它们具有分配给它们的显式值。

- “`bits`”类型可能会添加新的位，前提是旧位的位置不变。请注意，在现有位之前插入新位或重新排序现有位将导致现有位的新位置，除非它们具有分配给它们的明确位置。

- “`range`”，“`length`”或“`pattern`”语句可扩展允许的值空间。

- 可以将“`default`”语句添加到没有默认值（直接或间接通过类型）的叶。

- 可以添加“`units`”声明。

- 可以添加或更新“`reference`”声明。

- “`must`”陈述可能会被删除，或者放宽其限制。

- “`when`”声明可能会被删除或放宽其限制。

- “`mandatory`”陈述可能被删除或从“`true`”改为“`false`”。

- “`min-elements`”语句可能会被删除或更改为需要更少的元素。

- “`max-elements`”语句可能会被删除，或被更改为允许更多的元素。

- 可以在不改变定义的语义的情况下添加或更改“`description`”语句。

- 可以将“`base`”声明添加到“`identity`”声明中。

- 如果至少有一个“基本”语句被留下，“`base`”语句可以从“`identityref`”类型中删除。

- 可以添加新的`typedefs`，分组(`groupings`)，`rpcs`，通知(`notifications`)，扩展(`extensions`)，功能(`features`)和身份(`identities`)。

- 如果新增的数据定义语句没有将强制节点（[第3节](../section-3/README.md)）添加到现有节点或模块或子模块的顶层，或者如果它们有条件地依赖于新功能（即，有“`if-feature`“的陈述，指的是一个新的特征）。

- 可能会添加新的“`case`”声明。

- 代表状态数据的节点可以改变来代表配置，只要它不是强制性的（[第3节](../section-3/README.md)）。

- 只要节点不是强制性的（[第3节](../section-3/README.md)），就可以删除“`if-feature`”语句。

- 可以添加“`status`”语句，或从“`current`”更改为“`deprecated`”或“`obsolete`”，或从“`deprecated`”更改为“`obsolete`”。

- 一个“`type`”语句可以用另一个“`type`”语句替换，这个语句不会改变类型的语法或语义。例如，一个内联类型定义可能被一个`typedef`替换，但是一个`int8`类型不能被一个`int16`替换，因为语法会改变。

- 任何一组数据定义节点都可以用另一组语法和语义上等同的节点来代替。例如，一组叶子可能被一个分组的“`uses`”语句替换为相同的叶子。

- 一个模块可以被拆分成一组子模块，或者一个子模块可以被拆除，前提是模块中的定义除了这里所允许的以外没有任何变化。

- 如果前缀的所有本地使用也被改变，则“`prefix`”语句可能会改变。
